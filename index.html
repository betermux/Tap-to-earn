<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fruit Ninja Clone</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body, html { width:100%; height:100%; overflow:hidden; background:#111; }
    #canvas { display:block; }
    #hud {
      position:absolute; top:10px; left:10px; color:#fff;
      font-family:sans-serif; font-size:20px; text-shadow:1px 1px 2px #000;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hud">Score: 0 &nbsp; Lives: 3 &nbsp; Combo: 0</div>

  <script>
  /* ===== Base64 Assets ===== */
  const base = {
    bg: 'data:image/jpeg;base64,/*PLACEHOLDER_BG*/',
    apple: 'data:image/png;base64,/*PLACEHOLDER_APPLE*/',
    banana: 'data:image/png;base64,/*PLACEHOLDER_BANANA*/',
    orange: 'data:image/png;base64,/*PLACEHOLDER_ORANGE*/',
    watermelon: 'data:image/png;base64,/*PLACEHOLDER_WATERMELON*/',
    grape: 'data:image/png;base64,/*PLACEHOLDER_GRAPE*/',
    bomb: 'data:image/png;base64,/*PLACEHOLDER_BOMB*/',
    sliceSnd: 'data:audio/mp3;base64,/*PLACEHOLDER_SLICE*/',
    bombSnd: 'data:audio/mp3;base64,/*PLACEHOLDER_BOMB*/'
  };

  /* ===== Preload ===== */
  const images = {};
  const sounds = {};

  for (let key in base) {
    if (base[key].startsWith('data:image/')) {
      let img = new Image();
      img.src = base[key];
      images[key] = img;
    } else {
      let audio = new Audio(base[key]);
      sounds[key] = audio;
    }
  }

  /* ===== Canvas Setup ===== */
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = innerWidth;
  let H = canvas.height = innerHeight;

  window.addEventListener('resize', ()=>{
    W = canvas.width = innerWidth;
    H = canvas.height = innerHeight;
  });

  /* ===== Game Variables ===== */
  let score = 0, lives = 3, combo = 0, comboTimer = null;
  const fruits = [];
  const pointer = { x:0, y:0, down:false };

  const types = ['apple','banana','orange','watermelon','grape'];
  const GRAVITY = 0.4;

  /* ===== Utilities ===== */
  function rnd(min,max){return Math.random()*(max-min)+min;}

  /* ===== Classes ===== */
  class Fruit {
    constructor() {
      this.type = Math.random() < 0.05 ? 'bomb' : types[Math.floor(rnd(0,types.length))];
      this.img = images[this.type];
      this.r = rnd(30,50);
      this.x = rnd(this.r, W-this.r);
      this.y = H + this.r;
      this.vx = rnd(-4,4);
      this.vy = rnd(-15, -10);
      this.sliced = false;
      this.rotation = rnd(-0.1,0.1);
      this.angle = 0;
      this.color = this.type=='bomb'?'red':'transparent';
    }

    update(){
      this.vy += GRAVITY;
      this.x += this.vx;
      this.y += this.vy;
      this.angle += this.rotation;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(this.angle);
      ctx.drawImage(this.img, -this.r, -this.r, this.r*2, this.r*2);
      ctx.restore();
    }
    isOffscreen(){
      return this.y > H + this.r;
    }
  }

  /* ===== Spawn Loop ===== */
  function spawn(){
    fruits.push(new Fruit());
  }
  setInterval(spawn, 800);

  /* ===== Input ===== */
  canvas.addEventListener('mousedown', ()=>pointer.down=true);
  canvas.addEventListener('mouseup', ()=>pointer.down=false);
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
  });
  canvas.addEventListener('touchstart', e=>{pointer.down=true;});
  canvas.addEventListener('touchend', e=>{pointer.down=false;});
  canvas.addEventListener('touchmove', e=>{
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.touches[0].clientX - rect.left;
    pointer.y = e.touches[0].clientY - rect.top;
  });

  /* ===== Game Loop ===== */
  function update(){
    for (let i = fruits.length-1; i>=0; i--){
      let f = fruits[i];
      f.update();

      if (f.isOffscreen()){
        fruits.splice(i,1);
        if (!f.sliced && f.type!='bomb'){
          lives--;
          combo = 0;
          if (lives<=0){
            alert(`Game Over! Final: ${score}`);
            location.reload();
          }
        }
      } else if (pointer.down && !f.sliced) {
        let dx = f.x - pointer.x;
        let dy = f.y - pointer.y;
        if (Math.hypot(dx,dy) < f.r) {
          f.sliced = true;
          if (f.type=='bomb'){
            sounds.bombSnd.currentTime = 0;
            sounds.bombSnd.play();
            lives = 0;
            alert(`Bomb hit! Final: ${score}`);
            location.reload();
          } else {
            sounds.sliceSnd.currentTime = 0;
            sounds.sliceSnd.play();
            fruits.splice(i,1);
            score += 10;
            combo++;
            clearTimeout(comboTimer);
            comboTimer = setTimeout(()=>combo=0,1500);
          }
        }
      }
    }
  }

  function draw(){
    ctx.drawImage(images.bg, 0,0, W, H);
    fruits.forEach(f=>f.draw());
    ctx.fillStyle = '#fff';
    ctx.font = '18px sans-serif';
    if (combo>1){
      ctx.fillStyle = 'yellow';
      ctx.fillText(`Combo Ã—${combo}`, 10, H -30);
    }
  }

  function loop(){
    update();
    draw();
    document.getElementById('hud').innerHTML = `
      Score: ${score} &nbsp; Lives: ${lives} &nbsp; Combo: ${combo>1?combo:''}
    `;
    requestAnimationFrame(loop);
  }
  loop();

  </script>
</body>
</html>